/* this file is generated by gen_luabuild_h.lua, DO NOT MODIFY THIS! */
#ifndef luabuild_h
#define luabuild_h


#include <lua.h>
#include <lauxlib.h>


static int load_chunk(lua_State *L) {
  size_t bufflen = 13945;
  char buff[] = 
    "local DEBUG = false\nlocal VERBOSE = false\nlocal info = {\n ROOT = [[.."
    "\\]];\n SRCDIR = [[..\\src\\]];\n DSTDIR = [[dstdir\\]];\n\n RM = 'del';"
    "\n CP = 'copy /y';\n QUIET = ' >nul 2>nul';\n}\ninfo.gcc = {\n CC = 'gcc"
    " $CFLAGS $flags -c $input';\n LD = 'gcc $CFLAGS $flags -o $output $input"
    " $libs';\n AR = 'ar rcs $output $input';\n RC = 'windres -i $input -o $R"
    "COUT';\n RCOUT = '${output}.o';\n OBJ = '.o';\n}\ninfo.gcc_dbg = {\n bas"
    "e = info.gcc;\n CFLAGS = '-std=c99 -ggdb -pipe -O0 -Wall -fno-strict-ali"
    "asing';\n}\ninfo.gcc_rel = {\n base = info.gcc;\n CFLAGS = '-std=c99 -s "
    "-pipe -O3 -Wall -fno-strict-aliasing';\n}\ninfo.vs = {\n CC = 'cl /nolog"
    "o $CFLAGS $flags /c $input';\n LD = 'link /nologo $LDFLAGS $flags /OUT:\""
    "$output\" $input $libs';\n AR = 'lib /nologo /OUT:$output $input';\n RC "
    "= 'rc /nologo /Fo\"$RCOUT\" $input';\n RCOUT = '${output}.res';\n OBJ = "
    "'.obj';\n}\ninfo.vs_dbg = {\n base = info.vs;\n CFLAGS = '/W3 /D_CRT_SEC"
    "URE_NO_DEPRECATE '..\n '/MTd /Zi /Ob0 /Od /RTC1 /D _DEBUG';\n LDFLAGS = "
    "'/DEBUG /INCREMENTAL:NO /PDB:\"$output.pdb\"';\n}\ninfo.vs_rel = {\n bas"
    "e = info.vs;\n CFLAGS = '/nologo /W3 /D_CRT_SECURE_NO_DEPRECATE '..\n '/"
    "MT /GS- /GL /Gy /Oy- /O2 /Oi /DNDEBUG';\n LDFLAGS = '/OPT:REF /OPT:ICF /"
    "INCREMENTAL:NO /LTCG:incremental';\n}\ninfo.vs_rel_pdb = {\n base = info"
    ".vs;\n CFLAGS = '/nologo /W3 /D_CRT_SECURE_NO_DEPRECATE '..\n '/MT /GS- "
    "/GL /Gy /Oy- /O2 /Oi /Zi /DNDEBUG';\n LDFLAGS = '/OPT:REF /OPT:ICF /INCR"
    "EMENTAL:NO /LTCG:incremental /DEBUG:FASTLINK /PDB:\"$output.pdb\"';\n}\n"
    "info.vs_rel_min = {\n base = info.vs;\n CFLAGS = '/nologo /W3 /D_CRT_SEC"
    "URE_NO_DEPRECATE '..\n '/MT /GS- /GL /Gy /O1 /Ob1 /Oi /Oy- /DNDEBUG';\n "
    "LDFLAGS = '/OPT:REF /OPT:ICF /INCREMENTAL:NO /LTCG:incremental';\n}\n\nl"
    "ocal function find_version()\n local LUA_VERSION_MAJOR\n local LUA_VERSI"
    "ON_MINOR\n local LUA_VERSION_RELEASE\n local LUA_COPYRIGHT\n local LUA_R"
    "ELEASE\n\n io.input(info.SRCDIR .. \"lua.h\")\n for line in io.lines() d"
    "o\n local v\n v = line:match \"#define%s+LUA_VERSION_MAJOR%s+\\\"(%d+)\\"
    "\"\"\n repeat\n if v then LUA_VERSION_MAJOR = v break end\n v = line:mat"
    "ch \"#define%s+LUA_VERSION_MINOR%s+\\\"(%d+)\\\"\"\n if v then LUA_VERSI"
    "ON_MINOR = v break end\n v = line:match \"#define%s+LUA_VERSION_RELEASE%"
    "s+\\\"(%d+)\\\"\"\n if v then LUA_VERSION_RELEASE = v break end\n v = li"
    "ne:match \"#define%s+LUA_COPYRIGHT.-\\\"%s*(.-)\\\"\"\n if v then LUA_CO"
    "PYRIGHT = v break end\n v = line:match \"#define%s+LUA_RELEASE%s+\\\"(.-"
    ")\\\"\"\n if v then LUA_RELEASE = v break end\n until true\n end\n io.in"
    "put():close()\n io.input(io.stdin)\n\n if not LUA_VERSION_MAJOR then\n a"
    "ssert(LUA_RELEASE, \"can not find Lua release!!\")\n LUA_VERSION_MAJOR,\n"
    " LUA_VERSION_MINOR,\n LUA_VERSION_RELEASE = LUA_RELEASE:match \"^Lua (%d"
    "+)%.(%d+)%.(%d+)\"\n assert(LUA_VERSION_MAJOR, \"can not find Lua releas"
    "e!!\")\n end\n print((\"find Lua release: Lua %d.%d.%d\\n%s\"):format(\n"
    " LUA_VERSION_MAJOR, LUA_VERSION_MINOR, LUA_VERSION_RELEASE,\n LUA_COPYRI"
    "GHT))\n info.LUA_VERSION_MAJOR = LUA_VERSION_MAJOR\n info.LUA_VERSION_MI"
    "NOR = LUA_VERSION_MINOR\n info.LUA_VERSION_RELEASE = LUA_VERSION_RELEASE"
    "\n info.LUA_COPYRIGHT = LUA_COPYRIGHT\n info.LUAV = LUA_VERSION_MAJOR..L"
    "UA_VERSION_MINOR\n info.LUA_RELEASE = (\"%d.%d.%d\"):format(\n LUA_VERSI"
    "ON_MAJOR,\n LUA_VERSION_MINOR,\n LUA_VERSION_RELEASE)\nend\n\nlocal func"
    "tion expand(s, t)\n local count = 0\n local function replace(sv, space)\n"
    " sv = t and t[sv] or info[sv]\n if sv then\n if type(sv) == \"table\" th"
    "en\n sv = table.concat(sv, \" \")\n end\n sv = sv .. (space or \"\")\n c"
    "ount = count + 1\n end\n return sv or \"\"\n end\n assert(s, \"template "
    "expected\")\n while true do\n local old = count\n s = s:gsub(\"$%{([%w_]"
    "+)%}\", replace)\n s = s:gsub(\"$([%w_]+)(%s*)\", replace)\n if old == c"
    "ount then return s end\n end\nend\n\nlocal function patch_rcfile(file)\n"
    " local myInfo = {\n LUA_CSV_RELEASE = (\"%d,%d,%d,0\"):format(\n info.LU"
    "A_VERSION_MAJOR,\n info.LUA_VERSION_MINOR,\n info.LUA_VERSION_RELEASE);\n"
    " }\n\n print(\"[PATCH]\\t\"..file..\".rc\")\n io.input(\"res/\"..file..\""
    ".rc\")\n io.output(file..\".rc\")\n\n for line in io.lines() do\n io.wri"
    "te(expand(line, myInfo), \"\\n\")\n end\n\n io.input():close()\n io.outp"
    "ut():close()\n io.input(io.stdin)\n io.output(io.stdout)\nend\n\nlocal f"
    "unction patch_luaconf()\n local LUA_VDIR = info.LUA_VERSION_MAJOR..\".\""
    "..info.LUA_VERSION_MINOR\n local t = {\n path = [[\n#define LUA_PATH_DEF"
    "AULT \".\\\\?.lua;\" \".\\\\?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"?.lua;\""
    " LUA_CDIR \"?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"lua\\\\?.lua;\" LUA_CDIR"
    " \"lua\\\\?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"clibs\\\\?.lua;\" LUA_CDIR"
    " \"clibs\\\\?\\\\init.lua;\" \\\n\t\tLUA_CDIR \"..\\\\share\\\\lua\\\\]]"
    "..LUA_VDIR..[[\\\\?.lua;\" \\\n\t\tLUA_CDIR \"..\\\\share\\\\lua\\\\]].."
    "LUA_VDIR..[[\\\\?\\\\init.lua\"]];\n cpath = [[\n#define LUA_CPATH_DEFAU"
    "LT \".\\\\?.dll;\" \".\\\\loadall.dll;\" \\\n\t\tLUA_CDIR \"?.dll;\" LUA"
    "_CDIR \"loadall.dll;\" \\\n\t\tLUA_CDIR \"clibs\\\\?.dll;\" LUA_CDIR \"c"
    "libs\\\\loadall.dll;\" \\\n\t\tLUA_CDIR \"..\\\\lib\\\\lua\\\\]]..LUA_VD"
    "IR..[[\\\\?.dll;\" \\\n\t\tLUA_CDIR \"..\\\\lib\\\\lua\\\\]]..LUA_VDIR.."
    "[[\\\\loadall.dll\"]];\n }\n\n print(\"[PATCH]\\tluaconf.h\")\n io.input"
    "(info.SRCDIR..\"luaconf.h\")\n io.output \"src/luaconf.h\"\n local patch"
    "ed = 0\n local begin\n for line in io.lines() do\n if patched < 2 then\n"
    " if begin and not line:match \"\\\\$\" then\n line = t[begin]\n patched "
    "= patched + 1\n begin = nil\n elseif line:match \"#define%s+LUA_PATH_DEF"
    "AULT\" then\n begin = \"path\"\n elseif line:match \"#define%s+LUA_CPATH"
    "_DEFAULT\" then\n begin = \"cpath\"\n end\n end\n\n if not begin then io"
    ".write(line, \"\\n\") end\n end\n io.input():close()\n io.output():close"
    "()\n io.input(io.stdin)\n io.output(io.stdout)\nend\n\nlocal function gl"
    "ob(pattern)\n local fh = assert(io.popen(\"DIR /B /W \"..pattern))\n loc"
    "al files = {}\n for line in fh:lines() do\n files[#files+1] = line\n end"
    "\n fh:close()\n return files\nend\n\nlocal function map(files, f)\n loca"
    "l t = {}\n for i, v in ipairs(files) do\n local new = f(i, v)\n if new t"
    "hen t[#t+1] = new end\n end\n return t\nend\n\nlocal function tsub(files"
    ", pattern, replace)\n local t = {}\n for i, v in ipairs(files) do\n t[i]"
    " = v:gsub(pattern, replace)\n end\n return t\nend\n\nlocal function exec"
    "ute(fmt, t)\n local cmdline = expand(fmt, t)\n if VERBOSE then\n print(\""
    ">>\", cmdline)\n end\n return assert(os.execute(cmdline))\nend\n\nlocal "
    "function find_toolchain(toolchain)\n if not toolchain then\n --local env"
    " = os.getenv \"VS120COMNTOOLS\" or -- VS2013\n --os.getenv \"VS110COMNTO"
    "OLS\" or -- VS2012\n --os.getenv \"VS100COMNTOOLS\" or -- VS2010\n --os."
    "getenv \"VS90COMNTOOLS\" -- VS2008\n --if env then\n --execute(\"call \""
    "..env..\"vsvars32.bat\")\n --end\n if os.execute(expand[[cl $QUIET]]) th"
    "en\n print(\"find VS toolchain\")\n toolchain = \"vs\"\n elseif os.execu"
    "te(expand[[gcc --version $QUIET]]) then\n print(\"find GCC toolchain\")\n"
    " toolchain = \"gcc\"\n end\n if not toolchain then\n print(\"can not fin"
    "d toolchain!!!\")\n end\n toolchain = toolchain .. (DEBUG and \"_dbg\" o"
    "r \"_rel\")\n end\n print(\"use toolchain: \"..toolchain)\n info.TOOLCHA"
    "IN = toolchain\n local t = info[toolchain]\n repeat\n for k,v in pairs(t"
    ") do\n info[k] = v\n end\n t = t.base\n until not t\nend\n\nlocal functi"
    "on compile(file, flags)\n if type(file) == \"string\" then\n print(\"[CC"
    "]\\t\"..file)\n end\n return execute(\"$CC\", {\n input = file,\n flags "
    "= flags,\n })\nend\n\nlocal function compile_rc(file)\n print(\"[RC]\\t\""
    "..file)\n local t = {\n input = file,\n output = file,\n }\n if execute("
    "info.RC, t) then\n return expand(info.RCOUT, t)\n end\nend\n\nlocal func"
    "tion compile_def(name)\n print(\"[GEN]\\t\"..name..\".def\")\n local f ="
    " assert(io.popen(\"DUMPBIN /EXPORTS \"..name..\".exe\"))\n local exports"
    " = {\n \"LIBRARY \"..name..\".dll\",\n \"EXPORTS\",\n }\n for line in f:"
    "lines() do\n local ordinal, hint, rva, api =\n line:match \"(%d+)%s+(%x+"
    ")%s+(%x+)%s+([%a_][%w_]+)\"\n if ordinal then\n -- exports[#exports + 1]"
    " = (\"%s=%s.exe.%s @%d\"):format(api, name, api, ordinal)\n exports[#exp"
    "orts + 1] = (\"%s=%s @%d\"):format(api, api, ordinal)\n end\n end\n f:cl"
    "ose()\n local def = name .. \".def\"\n local f = assert(io.open(def, \"w"
    "\"))\n f:write(table.concat(exports, \"\\n\"))\n f:close()\n return def\n"
    "end\n\nlocal function link(target, files, flags, libs)\n print(\"[LINK]\\"
    "t\"..target)\n return execute(info.LD, {\n flags = flags,\n input = file"
    "s,\n output = target,\n libs = libs or \"Advapi32.lib\",\n })\nend\n\nlo"
    "cal function library(lib, files)\n print(\"[AR]\\t\"..lib)\n return exec"
    "ute(info.AR, {\n output = lib,\n input = files,\n })\nend\n\nlocal funct"
    "ion buildone_luas()\n patch_rcfile \"luas\"\n local LUAV = info.LUAV\n l"
    "ocal rc = compile_rc \"luas.rc\"\n local flags = { \"-DLUA_BUILD_AS_DLL "
    "-DMAKE_LUA -I$SRCDIR\" }\n local ldflags = {}\n if tonumber(LUAV) >= 53 "
    "then\n flags[#flags+1] = \"-DHAVE_LPREFIX\"\n end\n if info.TOOLCHAIN:ma"
    "tch \"^gcc\" then\n ldflags[#ldflags+1] = \"-Wl,--out-implib,liblua\"..L"
    "UAV..\".exe.a\"\n end\n compile(\"src/one.c\", flags)\n --if tonumber(LU"
    "AV) >= 54 then\n -- link(\"lua.exe\", \"one$OBJ \"..rc, ldflags)\n -- el"
    "se\n link(\"lua\"..LUAV..\".exe\", \"one$OBJ \"..rc, ldflags)\n if info."
    "TOOLCHAIN:match \"^vs\" then\n execute[[move /Y lua${LUAV}.lib lua${LUAV"
    "}exe.lib $QUIET]]\n execute[[move /Y lua${LUAV}.exp lua${LUAV}exe.exp $Q"
    "UIET]]\n end\n --end\nend\n\nlocal function buildone_luadll(noproxy)\n l"
    "ocal LUAV = info.LUAV\n local ldflags = {}\n local is_gcc = info.TOOLCHA"
    "IN:match \"^gcc\"\n if is_gcc or noproxy then\n patch_rcfile \"luadll\"\n"
    " local rc = compile_rc \"luadll.rc\"\n local flags = { \"-DLUA_BUILD_AS_"
    "DLL -DMAKE_LIB -I$SRCDIR\" }\n if is_gcc then\n if tonumber(LUAV) >= 53 "
    "then\n flags[#flags+1] = \"-DHAVE_LPREFIX\"\n end\n ldflags[#ldflags+1] "
    "= \"-mdll\"\n ldflags[#ldflags+1] = \"-Wl,--out-implib,liblua\"..LUAV..\""
    ".dll.a\"\n ldflags[#ldflags+1] = \"-Wl,--output-def,lua\"..LUAV..\".def\""
    "\n else\n ldflags[#ldflags+1] = \"/DLL\"\n end\n compile(\"src/one.c \","
    " flags)\n link(\"lua\"..LUAV..\".dll\", \"one$OBJ \"..rc, ldflags)\n els"
    "e\n patch_rcfile \"luaproxy\"\n local rc = compile_rc \"luaproxy.rc\"\n "
    "local def = compile_def(\"lua\"..LUAV)\n ldflags[#ldflags+1] = \"/DLL\"\n"
    " ldflags[#ldflags+1] = \"/NOENTRY\"\n ldflags[#ldflags+1] = \"/DEF:\"..d"
    "ef\n ldflags[#ldflags+1] = \"/IMPLIB:lua${LUAV}.lib\"\n ldflags[#ldflags"
    "+1] = \"/DELAYLOAD:lua${LUAV}.exe\"\n ldflags[#ldflags+1] = \"lua${LUAV}"
    "exe.lib\"\n compile(\"src/lproxy.c\", \"-I$SRCDIR\")\n link(\"lua\"..LUA"
    "V..\".dll\", \"lproxy.obj \"..rc, ldflags, \"kernel32.lib delayimp.lib\""
    ")\n execute[[$RM /s/q lua${LUAV}.dll.pdb 2>nul]]\n end\nend\n\nlocal fun"
    "ction build_lua()\n patch_rcfile \"lua\"\n local LUAV = info.LUAV\n loca"
    "l rc = compile_rc \"lua.rc\"\n local flags = \"-DLUA_BUILD_AS_DLL -I$SRC"
    "DIR\"\n local libs\n if info.TOOLCHAIN:match \"^gcc\" then\n libs = \"-L"
    ". -llua\"..LUAV..\".dll\"\n compile(\"src/lua.c \", flags)\n link(\"lua."
    "exe\", \"lua$OBJ \"..rc, nil, libs)\n else\n execute(\"$CP lua${LUAV}.ex"
    "e lua.exe\")\n end\nend\n\nlocal function buildone_luac()\n patch_rcfile"
    " \"luac\"\n local LUAV = info.LUAV\n local rc = compile_rc \"luac.rc\"\n"
    " local flags = \"-DMAKE_LUAC -I$SRCDIR\"\n if tonumber(LUAV) >= 53 then\n"
    " flags = flags .. \" -DHAVE_LPREFIX\"\n end\n compile(\"src/one.c \", fl"
    "ags)\n link(\"luac.exe\", \"one$OBJ \"..rc)\nend\n\nlocal function build"
    "_lualib()\n print(\"[CC]\\tlualib\")\n local files = map(glob(info.SRCDI"
    "R..\"*.c\"), function(_, v)\n if v ~= \"lua.c\" and v ~= \"luac.c\" and "
    "v ~= \"linit.c\" then\n return info.SRCDIR .. v\n end\n end)\n files[#fi"
    "les+1] = \"src/lpath.c\"\n files[#files+1] = \"src/lminiz.c\"\n files[#f"
    "iles+1] = \"src/linit.c\"\n files[#files+1] = \"src/lfmt.c\"\n files[#fi"
    "les+1] = \"src/lmp.c\"\n local LUAV = info.LUAV\n compile(files, \"-DLUA"
    "_BUILD_AS_DLL -I$SRCDIR\")\n if info.TOOLCHAIN:match \"^gcc\" then\n lib"
    "rary(\"liblua\"..LUAV..\".a\",\n tsub(files, \".*[/\\\\]([^/\\\\]+).c$\""
    ", \"%1.o\"))\n else\n library(\"lua\"..LUAV..\"s.lib\",\n tsub(files, \""
    ".*[/\\\\]([^/\\\\]+).c$\", \"%1.obj\"))\n end\n execute(\"$RM /s /q *.o "
    "*.obj $QUIET\")\nend\n\nlocal function make_dirs()\n print(\"[MKDIR]\\t\""
    "..info.DSTDIR)\n execute [[del /s /q $DSTDIR $QUIET]]\n execute [[mkdir "
    "${DSTDIR} $QUIET]]\n execute [[mkdir ${DSTDIR}clibs $QUIET]]\n execute ["
    "[mkdir ${DSTDIR}doc $QUIET]]\n execute [[mkdir ${DSTDIR}lua $QUIET]]\n e"
    "xecute [[mkdir ${DSTDIR}include $QUIET]]\n execute [[mkdir ${DSTDIR}lib "
    "$QUIET]]\nend\n\nlocal function install_doc()\n print(\"[INSTALL]\\tdocu"
    "ments\")\n for _, v in ipairs(glob(info.ROOT..\"doc\")) do\n execute([[$"
    "CP ${ROOT}doc\\$output ${DSTDIR}doc $QUIET]], { output = v })\n end\nend"
    "\n\nlocal function install_headers()\n print \"[INSTALL]\\theaders\"\n e"
    "xecute[[$CP src\\luaconf.h ${DSTDIR}include $QUIET]]\n execute[[$CP ${SR"
    "CDIR}lua.h ${DSTDIR}include $QUIET]]\n execute[[$CP ${SRCDIR}lua.hpp ${D"
    "STDIR}include $QUIET]]\n execute[[$CP ${SRCDIR}lauxlib.h ${DSTDIR}includ"
    "e $QUIET]]\n execute[[$CP ${SRCDIR}lualib.h ${DSTDIR}include $QUIET]]\ne"
    "nd\n\nlocal function install_executables()\n print \"[INSTALL]\\texecuta"
    "bles\"\n execute[[$CP lua.exe $DSTDIR $QUIET]]\n execute[[$CP luac.exe $"
    "DSTDIR $QUIET]]\n execute[[$CP lua$LUAV.exe $DSTDIR $QUIET]]\n execute[["
    "$CP lua$LUAV.dll $DSTDIR $QUIET]]\n execute[[$RM vc*.pdb]]\n execute[[$C"
    "P *.pdb $DSTDIR $QUIET]]\nend\n\nlocal function install_libraries()\n pr"
    "int \"[INSTALL]\\tlibraries\"\n execute[[$CP *.a ${DSTDIR}lib $QUIET]]\n"
    " execute[[$CP *.lib ${DSTDIR}lib $QUIET]]\n execute[[$CP *.def ${DSTDIR}"
    "lib $QUIET]]\n execute[[$CP *.exp ${DSTDIR}lib $QUIET]]\nend\n\nlocal fu"
    "nction dist()\n local assert = _G.assert\n _G.assert = function(...) ret"
    "urn ... end\n info.DSTDIR = expand[[Lua$LUAV$TOOLCHAIN\\]]\n print(\"[IN"
    "STALL]\\t\"..info.DSTDIR)\n make_dirs()\n install_doc()\n install_header"
    "s()\n install_executables()\n install_libraries()\n _G.assert = assert\n"
    "end\n\nlocal function cleanup()\n local assert = _G.assert\n _G.assert ="
    " function(...) return ... end\n print(\"[CLEANUP]\")\n execute[[$RM *.de"
    "f *.a *.exe *.dll *.rc *.o $QUIET]]\n execute[[$RM *.obj *.lib *.exp *.r"
    "es *.pdb *.ilk $QUIET]]\n execute[[$RM *.idb *.ipdb *.iobj $QUIET]]\n ex"
    "ecute[[$RM src/luaconf.h $QUIET]]\n _G.assert = assert\nend\n\n-- begin "
    "build\nwhile arg[1] and arg[1]:sub(1,1) == '-' do\n if arg[1] == '-v' th"
    "en\n VERBOSE = true\n elseif arg[1] == '-d' then\n DEBUG = true\n elseif"
    " arg[1] == '-h' or arg[1] == '-?' then\n print(arg[0]..\" [-v] [-d] [too"
    "lchain]\")\n print(\"support toolchain:\")\n local tls = {}\n for k,v in"
    " pairs(info) do\n if type(v) == 'table' and v.base then\n tls[#tls+1] = "
    "k\n end\n end\n table.sort(tls)\n print(\" \"..table.concat(tls, \"\\n \""
    "))\n return\n end\n table.remove(arg, 1)\nend\n\nfind_version()\npatch_l"
    "uaconf()\n\nfind_toolchain(arg[1])\nbuildone_luas()\nbuildone_luadll()\n"
    "--if tonumber(info.LUAV) < 54 then\n build_lua()\n--end\nbuildone_luac()"
    "\nbuild_lualib()\ndist()\ncleanup()\nprint \"[DONE]\"\n\n-- cc: cc='D:\\"
    "lua53\\lua.exe'\n"
;

  return luaL_loadbuffer(L, buff, bufflen, "=luabuild.lua");
}


#endif /* luabuild_h */
